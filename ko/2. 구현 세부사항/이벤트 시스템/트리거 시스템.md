# 트리거 시스템

## 개요

메이플 듀얼의 트리거 시스템은 게임 이벤트 발생 시 카드의 자동 효과를 실행하는 핵심 메커니즘입니다. `TriggerManager.mlua`를 통해 카드별 조건부 효과들이 게임 진행 중 적절한 타이밍에 자동으로 활성화되어 복잡한 상호작용과 전략적 깊이를 제공합니다.

## 트리거 시스템 아키텍처

### 핵심 컴포넌트

**TriggerManager.mlua**는 모든 카드 트리거를 중앙에서 관리합니다.

**주요 속성:**
```lua
property CardManager cardManager = nil
property Duel duel = nil
property ActionManager actionManager = nil
property CommandManager commandManager = nil
property TaskManager taskManager = nil
property History history = nil

property any invoker = nil      -- 트리거를 발생시킨 객체
property any receiver = nil     -- 트리거를 받는 객체  
property table args = nil       -- 트리거 인수
```

## 트리거 실행 메커니즘

### InvokeTriggers 메서드

모든 트리거 실행의 시작점입니다.

```lua
method void InvokeTriggers(table invokerArray, table receiverArray, string triggerKey, table args, table eachArgs, table resultTable)
    -- 1. 카드 공개 처리
    local cardArray = self:ShareOpenCards(invokerArray, receiverArray, triggerKey, args, eachArgs, resultTable)
    for _, card in ipairs(cardArray) do
        card:Open()
        card:SetFace(false)
    end
    
    -- 2. 트리거 실행
    for _, invoker in ipairs(invokerArray) do
        self:RunTriggers(triggerKey, invoker, invoker, eachArgs and eachArgs[invoker] or args, resultTable and resultTable[invoker] or nil)
        for _, receiver in ipairs(receiverArray) do
            if receiver ~= invoker then
                self:RunTriggers(triggerKey, invoker, receiver, eachArgs and eachArgs[invoker] or args, resultTable and resultTable[invoker] or nil)
            end
        end
    end
end
```

### RunTriggers 메서드

개별 객체에 대해 트리거를 실행합니다.

```lua
method void RunTriggers(string triggerKey, Object invoker, Object receiver, table args, table result)
    if not receiver.triggerNameArray then return end
    
    -- 컨텍스트 백업
    local backupInvoker = self.invoker
    local backupReceiver = self.receiver
    local backupArgs = self.args
    
    -- 현재 실행 컨텍스트 설정
    self.invoker = invoker
    self.receiver = receiver
    self.args = args
    
    -- 트리거 실행
    local triggerNameArray = _Table:ShallowCopy(receiver.triggerNameArray)
    for _, triggerName in ipairs(triggerNameArray) do
        if self:IsTriggerCondition(triggerKey, triggerName, invoker, receiver, args, result) then
            self:RunTrigger(triggerName, invoker, receiver, args, result)
        end
    end
    
    -- 컨텍스트 복원
    self.invoker = backupInvoker
    self.receiver = backupReceiver
    self.args = backupArgs
end
```

## 트리거 조건 시스템

### 조건 확인 메커니즘

```lua
method boolean IsTriggerCondition(string triggerKey, string triggerName, Object invoker, Object receiver, table args, table result)
    return _Util:Call(self, triggerName .. "Condition", {triggerKey, invoker, receiver, result, _Table:Unpack(args)})
end
```

### 주요 트리거 키(TriggerKey)

게임 이벤트별로 정의된 트리거 키들:

- **"Cast"** - 카드 시전 시
- **"Summon"** - 미니언 소환 시
- **"Death"** - 유닛 사망 시
- **"Damage"** - 피해를 받을 시
- **"Attack"** - 공격 시
- **"EndTurn"** - 턴 종료 시
- **"BeginTurn"** - 턴 시작 시

## 카드별 트리거 구현

### AirStrike 카드 예시

**트리거 조건:**
```lua
method boolean AirStrikeCondition(string triggerKey, Card invoker, Card receiver)
    return triggerKey == "Cast" and invoker == receiver
end
```

**트리거 효과:**
```lua
method void AirStrike(Card invoker, Card receiver)
    self.taskManager:RunProcess(function()
        local unitArray = receiver.player.opponent:GetUnits()
        local damage = 3
        
        -- 스킬 데미지 보너스 적용
        if receiver.player.skillDamage > 0 then
            damage += 4
        end
        
        -- 상대편 모든 유닛에 데미지
        self.taskManager:Damage(unitArray, receiver, damage, nil, "AirStrike", 0.075)
    end, "AirStrike")
end
```

### ArmorCrash 카드 예시

**트리거 조건:**
```lua
method boolean ArmorCrashCondition(string triggerKey, Card invoker, Card receiver)
    return triggerKey == "Cast" and invoker == receiver
end
```

**트리거 효과:**
```lua
method void ArmorCrash(Card invoker, Card receiver)
    self.taskManager:RunProcess(function()
        -- 상대편 랜덤 미니언 2마리의 최대 체력을 1로 설정
        local targets = receiver.player.opponent.field:ShareRandomMinions(2, nil)
        self.taskManager:InsertSetMaxHpEnchantment(targets, 1, nil, nil, "ArmorCrash", nil)
    end, "ArmorCrash")
end
```

### 조건부 트리거 예시 (ArrowBlow)

**트리거 조건:**
```lua
method boolean ArrowBlowCondition(string triggerKey, Card invoker, Card receiver)
    return triggerKey == "Cast" and invoker == receiver
end
```

**트리거 효과:**
```lua
method void ArrowBlow(Card invoker, Card receiver, table result, Minion target)
    self.taskManager:RunProcess(function()
        -- 타겟에 5 데미지
        local resultTable = self.taskManager:Damage({target}, receiver.player, 5, nil, "ArrowBlow", nil)
        
        -- 타겟이 죽지 않았으면 카드 2장 드로우
        if not resultTable[target].isDead then
            self.taskManager:Draw({[receiver.player] = 2}, nil, false)
        end
    end, "ArrowBlow")
end
```

## 트리거 체인 및 복합 효과

### ShareOpenCards 메서드

트리거 실행 전 관련 카드들을 공개합니다.

```lua
method table ShareOpenCards(table invokerArray, table receiverArray, string triggerKey, table args, table eachArgs, table resultTable)
    local cardArray = {}
    
    for _, invoker in ipairs(invokerArray) do
        for _, receiver in ipairs(receiverArray) do
            if receiver:IsCard() and receiver.triggerNameArray then
                for _, triggerName in ipairs(receiver.triggerNameArray) do
                    if self:IsTriggerCondition(triggerKey, triggerName, invoker, receiver, 
                                               eachArgs and eachArgs[invoker] or args, 
                                               resultTable and resultTable[invoker] or nil) and
                       not _Table:Contains(cardArray, receiver) then
                        table.insert(cardArray, receiver)
                    end
                end
            end
        end
    end
    
    return cardArray
end
```

### 트리거 체인 실행

```lua
-- 트리거가 다른 트리거를 발생시키는 경우
method void ChainTriggerExample(Card invoker, Card receiver)
    self.taskManager:RunProcess(function()
        -- 첫 번째 효과 실행
        self.taskManager:Damage(targetArray, receiver, damage, nil, "ChainEffect1", nil)
        
        -- 체인 트리거 발생
        self:InvokeTriggers({receiver}, {receiver.player}, "ChainEffect", {}, nil, nil)
    end, "ChainTriggerExample")
end
```

## 트리거 실행 플로우

### 카드 시전 시 트리거 플로우

```mermaid
graph TD
    A[플레이어 카드 시전] --> B[TaskManager:PlayCard]
    B --> C[TriggerManager:InvokeTriggers]
    C --> D[triggerKey = "Cast"]
    D --> E[ShareOpenCards]
    E --> F[카드 공개 애니메이션]
    F --> G[RunTriggers 호출]
    G --> H[각 카드의 triggerNameArray 확인]
    H --> I{Condition 체크}
    I -->|조건 만족| J[트리거 효과 실행]
    I -->|조건 불만족| K[다음 트리거]
    J --> L[TaskManager:RunProcess]
    L --> M[실제 게임 로직 실행]
    M --> K
    K --> N[모든 트리거 완료]
```

### 미니언 소환 시 트리거 플로우

```mermaid
graph TD
    A[미니언 카드 시전] --> B[미니언 필드 배치]
    B --> C[triggerKey = "Summon"]
    C --> D[다른 카드들의 Summon 트리거 확인]
    D --> E["환영 소환" 등 연계 효과]
    E --> F[트리거 체인 실행]
    F --> G[최종 보드 상태 확정]
```

## 고급 트리거 패턴

### 멀티 타겟 트리거

```lua
method void MultiTargetExample(Card invoker, Card receiver, table result, table targets)
    self.taskManager:RunProcess(function()
        for _, target in ipairs(targets) do
            -- 각 타겟에 대해 개별 처리
            local damage = self:CalculateTargetDamage(target)
            self.taskManager:Damage({target}, receiver, damage, nil, "MultiTarget", nil)
        end
    end, "MultiTargetExample")
end
```

### 조건부 연쇄 트리거

```lua
method void ConditionalChainExample(Card invoker, Card receiver)
    self.taskManager:RunProcess(function()
        local result = self.taskManager:SomeAction()
        
        if result.success then
            -- 성공 시 추가 트리거 발생
            self:InvokeTriggers({receiver}, allCards, "Success", {result = result}, nil, nil)
        else
            -- 실패 시 다른 트리거 발생
            self:InvokeTriggers({receiver}, allCards, "Failure", {result = result}, nil, nil)
        end
    end, "ConditionalChainExample")
end
```

## 성능 최적화

### 트리거 필터링

```lua
-- 불필요한 트리거 실행 방지
method boolean OptimizedTriggerCondition(string triggerKey, Card invoker, Card receiver)
    -- 빠른 조건 체크 먼저
    if triggerKey ~= "Cast" then return false end
    if invoker ~= receiver then return false end
    
    -- 복잡한 조건 체크는 나중에
    return self:ComplexConditionCheck(invoker, receiver)
end
```

### 컨텍스트 관리

트리거 실행 중 컨텍스트를 백업하고 복원하여 중첩 트리거 실행을 안전하게 처리합니다.

## 디버깅 및 로깅

### 트리거 실행 추적

```lua
method void RunTrigger(string triggerName, any invoker, any receiver, table args, table result)
    -- 디버그 로깅
    if DEBUG_TRIGGERS then
        log(string.format("Trigger: %s, Invoker: %s, Receiver: %s", 
                         triggerName, tostring(invoker), tostring(receiver)))
    end
    
    _Util:Call(self, triggerName, {invoker, receiver, result, _Table:Unpack(args)})
end
```

## 코드 참조

### 핵심 파일
- `RootDesk/MyDesk/Components/Managers/TriggerManager.mlua` — 트리거 시스템 메인 로직
- `RootDesk/MyDesk/Components/Managers/TaskManager.mlua` — 트리거 효과 실행을 위한 태스크 관리
- `RootDesk/MyDesk/Components/Managers/ActionManager.mlua` — 트리거 액션 애니메이션 처리

### 주요 메서드
- `TriggerManager:InvokeTriggers()` — 트리거 실행 시작점
- `TriggerManager:RunTriggers()` — 개별 객체 트리거 실행  
- `TriggerManager:IsTriggerCondition()` — 트리거 조건 확인
- `TriggerManager:ShareOpenCards()` — 트리거 발동 카드 공개

## 트리거 시스템의 특징

### 장점
1. **자동화**: 조건 만족 시 효과 자동 실행
2. **확장성**: 새 카드 추가 시 트리거만 구현하면 됨
3. **체인 지원**: 트리거가 다른 트리거를 발생시킬 수 있음
4. **타이밍 정확성**: 게임 이벤트와 정확히 동기화

### 설계 원칙
1. **명명 규칙**: `[CardName]`과 `[CardName]Condition` 페어
2. **상태 무결성**: 트리거 실행 중 컨텍스트 보존
3. **성능**: 불필요한 트리거 실행 최소화
4. **가독성**: 각 카드별 트리거 로직 독립성

이 트리거 시스템은 메이플 듀얼의 카드 게임으로서의 복잡성과 전략적 깊이를 구현하는 핵심 엔진으로, 수백 가지의 카드 효과들이 유기적으로 상호작용할 수 있게 합니다.
