# 리소스 관리 도구

## 개요

메이플 듀얼의 리소스 관리는 게임 성능과 개발 효율성에 직접적인 영향을 미치는 핵심 요소입니다. 이 가이드는 `ResourceManager.mlua`를 활용한 효율적인 리소스 관리 방법과 애셋 구성 베스트 프랙티스를 제시합니다.

## ResourceManager.mlua 활용

### 기본 리소스 구조
```lua
-- ResourceManager.mlua 기본 구조
@Component
script ResourceManager extends Component
    property table cardResource = {}
    property table uiResource = {}  
    property table effectResource = {}
    property table soundResource = {}
    
    @ExecSpace("ClientOnly")
    method void OnBeginPlay()
        self:LoadAllResources()
    end
end
```

### 리소스 그룹별 관리
```lua
-- 카드 관련 리소스
method void LoadCardResources()
    self.cardResource = {
        -- 카드 프레임
        frames = {
            common = "CommonCardFrame",
            rare = "RareCardFrame", 
            epic = "EpicCardFrame",
            unique = "UniqueCardFrame",
            legendary = "LegendaryCardFrame"
        },
        -- 직업별 배경
        jobBackgrounds = {
            warrior = "WarriorCardBg",
            magician = "MagicianCardBg",
            bowman = "BowmanCardBg",
            thief = "ThiefCardBg", 
            pirate = "PirateCardBg"
        }
    }
end

-- UI 관련 리소스
method void LoadUIResources()
    self.uiResource = {
        -- 공통 UI 요소
        common = {
            buttonNormal = "ButtonNormal",
            buttonHover = "ButtonHover", 
            buttonPressed = "ButtonPressed",
            panelBg = "PanelBackground",
            scrollBar = "ScrollBar"
        },
        -- 모듈별 UI
        modules = {
            lobby = "LobbyPanelBg",
            shop = "ShopPanelBg", 
            card = "CardPanelBg",
            duel = "DuelPanelBg"
        }
    }
end

-- 이펙트 관련 리소스
method void LoadEffectResources()
    self.effectResource = {
        -- 전투 이펙트
        combat = {
            hit = "HitEffect",
            death = "DeathEffect",
            heal = "HealEffect",
            damage = "DamageEffect"
        },
        -- UI 이펙트  
        ui = {
            cardDraw = "CardDrawEffect",
            buttonClick = "ButtonClickEffect",
            pageTransition = "PageTransitionEffect"
        }
    }
end
```

## 리소스 로딩 최적화

### 프리로딩 시스템
```lua
-- 필수 리소스 미리 로딩
@ExecSpace("ClientOnly")
method void PreloadCriticalResources()
    local criticalResources = {
        -- 게임 시작 시 반드시 필요한 리소스들
        "LobbyBackground",
        "MainMenuMusic", 
        "CommonCardFrame",
        "BasicUIElements"
    }
    
    _ResourceService:PreloadAsync(criticalResources, function(progress)
        self:UpdateLoadingProgress(progress)
    end)
end

-- 상황별 리소스 로딩
method void PreloadForDuel()
    local duelResources = {
        -- 듀얼 시 필요한 리소스들
        "DuelField",
        "TurnTimer",
        "MinionModels", 
        "SkillEffects",
        "CombatSounds"
    }
    
    _ResourceService:PreloadAsync(duelResources)
end

method void PreloadForShop() 
    local shopResources = {
        "CardPackModels",
        "ShopBackground",
        "CoinEffects",
        "PurchaseSounds"
    }
    
    _ResourceService:PreloadAsync(shopResources)
end
```

### 지연 로딩 (Lazy Loading)
```lua
-- 필요할 때만 로딩하는 리소스들
method string GetResource(string category, string resourceName)
    if not self.loadedResources[category] then
        self.loadedResources[category] = {}
    end
    
    if not self.loadedResources[category][resourceName] then
        -- 처음 요청 시에만 로딩
        self.loadedResources[category][resourceName] = self:LoadResourceFromDisk(category, resourceName)
    end
    
    return self.loadedResources[category][resourceName]
end
```

## 애셋 구성 가이드

### 폴더 구조 최적화
```
RootDesk/MyDesk/
├── Images/
│   ├── Cards/           # 카드 이미지
│   │   ├── Fronts/      # 카드 앞면
│   │   ├── Backs/       # 카드 뒷면  
│   │   └── Frames/      # 카드 프레임
│   ├── UI/              # UI 요소
│   │   ├── Buttons/     # 버튼 이미지
│   │   ├── Panels/      # 패널 배경
│   │   └── Icons/       # 아이콘들
│   └── Effects/         # 이펙트 스프라이트
├── Models/              # 3D 모델
│   ├── Cards/           # 카드 3D 모델
│   ├── Minions/         # 미니언 모델
│   └── Environment/     # 환경 오브젝트
├── Sounds/              # 사운드 파일
│   ├── BGM/            # 배경음악
│   ├── SFX/            # 효과음
│   └── Voice/          # 음성
└── Materials/          # 머티리얼
    ├── Cards/          # 카드 머티리얼
    └── UI/             # UI 머티리얼
```

### 명명 규칙 표준화
```lua
-- 일관된 명명 규칙 적용
local NAMING_CONVENTIONS = {
    cards = {
        front = "{cardName}_Front",
        back = "{cardName}_Back", 
        model = "{cardName}_Model"
    },
    ui = {
        button = "{moduleName}_{buttonName}_Btn",
        panel = "{moduleName}_Panel_Bg",
        icon = "{category}_{iconName}_Icon"
    },
    sounds = {
        effect = "{effectName}_SFX",
        bgm = "{sceneName}_BGM",
        voice = "{characterName}_{actionName}_Voice"
    }
}

method string GetStandardResourceName(string category, string type, table params)
    local template = NAMING_CONVENTIONS[category][type]
    return string.format(template, table.unpack(params))
end
```

### 해상도별 리소스 관리
```lua
-- 디바이스별 최적화된 리소스 선택
method string GetOptimizedResource(string baseName)
    local screenInfo = _ScreenService:GetScreenInfo()
    local dpi = screenInfo.dpi
    
    if dpi >= 300 then
        -- 고해상도 디바이스용
        return baseName .. "_HD"
    elseif dpi >= 200 then
        -- 중간 해상도
        return baseName .. "_MD"  
    else
        -- 저해상도
        return baseName .. "_SD"
    end
end
```

## 메모리 관리

### 리소스 캐싱 전략
```lua
-- LRU 캐시 구현
local ResourceCache = {}
ResourceCache.__index = ResourceCache

function ResourceCache:new(maxSize)
    return setmetatable({
        cache = {},
        usage = {},
        maxSize = maxSize or 100,
        currentSize = 0
    }, self)
end

function ResourceCache:get(key)
    local value = self.cache[key]
    if value then
        -- 사용 시간 업데이트
        self.usage[key] = _DateTime:GetTime()
        return value
    end
    return nil
end

function ResourceCache:put(key, value)
    if self.currentSize >= self.maxSize then
        self:evictLeastUsed()
    end
    
    self.cache[key] = value
    self.usage[key] = _DateTime:GetTime()
    self.currentSize += 1
end

function ResourceCache:evictLeastUsed()
    local oldestKey = nil
    local oldestTime = math.huge
    
    for key, time in pairs(self.usage) do
        if time < oldestTime then
            oldestTime = time
            oldestKey = key
        end
    end
    
    if oldestKey then
        self.cache[oldestKey] = nil
        self.usage[oldestKey] = nil
        self.currentSize -= 1
    end
end
```

### 자동 리소스 해제
```lua
-- 씬 변경 시 불필요한 리소스 해제
method void CleanupSceneResources(string leavingScene)
    local resourcesToCleanup = self.sceneResources[leavingScene]
    
    if resourcesToCleanup then
        for _, resource in ipairs(resourcesToCleanup) do
            if not self:IsSharedResource(resource) then
                _ResourceService:UnloadResource(resource)
            end
        end
        
        self.sceneResources[leavingScene] = nil
    end
end

-- 공유 리소스 여부 확인
method boolean IsSharedResource(string resourceName)
    local sharedResources = {
        "CommonCardFrame",
        "ButtonNormal", 
        "LoadingIcon",
        "ErrorSound"
    }
    
    return table.contains(sharedResources, resourceName)
end
```

## 리소스 검증 도구

### 누락된 리소스 검사
```lua
-- 게임 시작 시 리소스 무결성 검사
method table ValidateAllResources()
    local missingResources = {}
    
    -- 필수 리소스 목록
    local requiredResources = self:GetRequiredResourceList()
    
    for category, resources in pairs(requiredResources) do
        for _, resourceName in ipairs(resources) do
            if not self:ResourceExists(resourceName) then
                table.insert(missingResources, {
                    category = category,
                    name = resourceName
                })
            end
        end
    end
    
    if #missingResources > 0 then
        self:LogMissingResources(missingResources)
    end
    
    return missingResources
end

method boolean ResourceExists(string resourceName)
    local success, resource = pcall(function()
        return _ResourceService:GetResource(resourceName)
    end)
    
    return success and resource ~= nil
end
```

### 중복 리소스 탐지
```lua
method table FindDuplicateResources()
    local resourceHashes = {}
    local duplicates = {}
    
    local allResources = _ResourceService:GetAllResources()
    
    for _, resource in ipairs(allResources) do
        local hash = self:CalculateResourceHash(resource)
        
        if resourceHashes[hash] then
            table.insert(duplicates, {
                original = resourceHashes[hash],
                duplicate = resource.name
            })
        else
            resourceHashes[hash] = resource.name
        end
    end
    
    return duplicates
end
```

## 성능 모니터링

### 리소스 사용량 추적
```lua
-- 리소스 메모리 사용량 모니터링
method table GetResourceUsageStats()
    local stats = {
        totalMemory = 0,
        categoryBreakdown = {},
        topConsumers = {}
    }
    
    for category, resources in pairs(self.loadedResources) do
        local categoryMemory = 0
        
        for resourceName, resource in pairs(resources) do
            local size = self:GetResourceSize(resource)
            categoryMemory += size
            
            table.insert(stats.topConsumers, {
                name = resourceName,
                size = size,
                category = category
            })
        end
        
        stats.categoryBreakdown[category] = categoryMemory
        stats.totalMemory += categoryMemory
    end
    
    -- 메모리 사용량 순으로 정렬
    table.sort(stats.topConsumers, function(a, b) 
        return a.size > b.size 
    end)
    
    return stats
end

-- 리소스 로딩 시간 측정
method void TrackLoadingPerformance()
    local startTime = _DateTime:GetTime()
    
    -- 리소스 로딩...
    
    local endTime = _DateTime:GetTime()
    local loadTime = endTime - startTime
    
    self.performanceStats.avgLoadTime = 
        (self.performanceStats.avgLoadTime + loadTime) / 2
        
    if loadTime > self.performanceStats.maxLoadTime then
        self.performanceStats.maxLoadTime = loadTime
    end
end
```

## 자동화 도구

### 리소스 자동 압축
```lua
-- 빌드 시 리소스 최적화
method void OptimizeResourcesForBuild()
    local imagesToOptimize = self:GetImageResources()
    
    for _, image in ipairs(imagesToOptimize) do
        -- 이미지 압축 및 최적화
        self:CompressImage(image.path, {
            quality = 85,
            format = "webp",
            maxWidth = 1024,
            maxHeight = 1024
        })
    end
    
    local soundsToOptimize = self:GetSoundResources()
    
    for _, sound in ipairs(soundsToOptimize) do
        -- 오디오 압축
        self:CompressAudio(sound.path, {
            bitrate = 128,
            format = "ogg"
        })
    end
end
```

### 사용하지 않는 리소스 탐지
```lua
method table FindUnusedResources()
    local allResources = _ResourceService:GetAllResources()
    local usedResources = self:ScanCodeForResourceReferences()
    local unusedResources = {}
    
    for _, resource in ipairs(allResources) do
        if not usedResources[resource.name] then
            table.insert(unusedResources, resource.name)
        end
    end
    
    return unusedResources
end
```

## 베스트 프랙티스

### 리소스 로딩 우선순위
```lua
-- 로딩 우선순위 정의
local LOADING_PRIORITIES = {
    critical = 1,    -- 게임 시작 필수
    high = 2,        -- 주요 게임플레이
    medium = 3,      -- 일반 기능
    low = 4          -- 부가 기능
}

method void LoadResourcesByPriority()
    for priority = 1, 4 do
        local resources = self:GetResourcesByPriority(priority)
        self:LoadResourceBatch(resources)
        
        if priority <= 2 then
            -- 중요한 리소스는 완전히 로딩 완료 후 다음 단계
            while not self:IsResourceBatchLoaded(resources) do
                _CoroutineService:Wait(0.1)
            end
        end
    end
end
```

### 리소스 프로파일링
```lua
-- 개발 모드에서 리소스 사용 프로파일링
method void StartResourceProfiling()
    if not DEBUG_MODE then return end
    
    self.profilingEnabled = true
    self.resourceAccessLog = {}
    
    _TimerService:SetTimerLoop(function()
        self:LogResourceUsage()
    end, 5.0) -- 5초마다 로깅
end

method void LogResourceUsage()
    local stats = self:GetResourceUsageStats()
    
    log(string.format("Total Memory: %d KB", stats.totalMemory / 1024))
    
    for category, memory in pairs(stats.categoryBreakdown) do
        log(string.format("%s: %d KB", category, memory / 1024))
    end
end
```

이 리소스 관리 가이드를 따르면 메이플 듀얼의 성능을 최적화하고, 개발 효율성을 크게 향상시킬 수 있습니다. 특히 모바일 환경에서의 메모리 제한과 로딩 시간을 고려한 전략적 리소스 관리가 게임의 성공에 핵심적인 역할을 합니다.
