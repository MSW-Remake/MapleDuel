# 디버깅과 테스트 가이드

## 개요

메이플 듀얼 개발 과정에서 효율적인 디버깅과 테스트는 게임 품질 보장의 핵심입니다. 이 가이드는 MapleStory Worlds 환경에서의 디버깅 기법, 로그 확인 방법, 성능 모니터링, 그리고 체계적인 테스트 접근법을 제시합니다.

## 로그 시스템

### 기본 로깅
**로그 출력 함수들:**
- `log()` — 기본 디버그 메시지 출력
- 조건부 로깅을 통한 디버그 모드 구분

### 개발자 로그 함수
- `_Developer:Log()` — 개발자 전용 상세 로그 출력

## 오류 처리

### 안전한 메서드 호출
**pcall 활용:**
- `pcall()` — 안전한 함수 실행
- 실행 성공 여부와 결과/오류 메시지 반환

### 서버 통신 오류 처리
- `Server.mlua :: Send()` — 서버 메서드 안전 실행
- `_Util.Call`과 `pcall` 조합으로 오류 처리

## 성능 모니터링

### 실행 시간 측정
**성능 측정:**
- `_DateTime:GetTime()` 활용한 실행 시간 측정
- 시작/종료 시간 차이 계산으로 성능 분석

### 메모리 사용량 체크
**리소스 정리:**
- `tweener:Destroy()` — 트위너 해제
- `_TimerService:ClearTimer()` — 타이머 정리

## 클라이언트-서버 동기화 디버깅

### 상태 불일치 확인
**동기화 검증:**
- 클라이언트/서버 상태 각각 로그 출력
- `@ExecSpace` 어노테이션으로 실행 환경 구분

### 명령어 동기화 추적
- `CommandManager.mlua :: RunCommand()` — 명령어 실행 로그
- 명령어명과 ID 추적으로 동기화 문제 해결

## 게임플레이 테스트

### 자동 테스트 봇 활용
```lua
-- Bot.mlua를 이용한 자동 테스트
bot:SetTestMode(true)
bot:PlayRandomCards(10) -- 10턴 자동 플레이
bot:CheckGameState() -- 게임 상태 검증
```

### 시나리오 테스트
```lua
-- 특정 상황 재현
function TestCardCombo()
    player:AddCardToHand("FireBolt")
    player:AddCardToHand("IceSpear") 
    player:SetMP(10)
    
    -- 콤보 실행
    player:PlayCard("FireBolt")
    player:PlayCard("IceSpear")
    
    -- 결과 검증
    assert(enemy.hp == expectedHp, "데미지 계산 오류")
end
```

## UI 테스트

### 모듈 상태 확인
```lua
-- UIManager 상태 디버깅
method void DebugUIState()
    log(string.format("현재 열린 모듈: %d개", self:GetOpenModuleCount()))
    
    for moduleName, module in pairs(self.modules) do
        if module.isOpen then
            log(string.format("열린 모듈: %s", moduleName))
        end
    end
end
```

### 애니메이션 테스트
```lua
-- 트위닝 애니메이션 검증
local tweener = _Tween:MoveTo(entity, targetPos, 1.0, EaseType.Linear)
_TimerService:SetTimerOnce(function()
    local currentPos = entity.TransformComponent.WorldPosition
    assert(math.abs(currentPos.x - targetPos.x) < 0.1, "애니메이션 위치 오류")
end, 1.1)
```

## 데이터 무결성 테스트

### 저장/로드 검증
```lua
-- 캐릭터 데이터 저장/로드 테스트
function TestDataPersistence()
    local originalMeso = character.meso
    character:SaveData()
    
    -- 데이터 변경
    character.meso = 0
    
    -- 데이터 로드
    character:LoadData()
    
    assert(character.meso == originalMeso, "데이터 저장/로드 실패")
end
```

### CSV 데이터 검증
```lua
-- Card.csv 데이터 유효성 검사
function ValidateCardData()
    local cardManager = _CardManager
    local dataSet = cardManager.dataSet
    
    for i = 1, dataSet:GetRowCount() do
        local name = dataSet:GetValue(i, "name")
        local cost = dataSet:GetValue(i, "cost")
        
        assert(cost >= 0 and cost <= 10, 
               string.format("카드 %s의 비용이 범위를 벗어남: %d", name, cost))
    end
end
```

## 네트워크 테스트

### 연결 상태 모니터링
```lua
-- 서버 요청 상태 확인
if _Server:IsRequesting() then
    log("서버 요청 진행 중...")
else
    log("서버 요청 완료 상태")
end
```

### 패킷 로스 시뮬레이션
```lua
-- 의도적인 요청 실패 테스트
method void TestNetworkFailure()
    -- 네트워크 요청 실패 상황 가정
    if math.random() < 0.1 then -- 10% 확률로 실패
        log("네트워크 요청 실패 시뮬레이션")
        return
    end
    
    -- 정상 처리
    _Server:Request(component, methodName, args)
end
```

## 회귀 테스트

### 기존 기능 검증
```lua
-- 핵심 게임플레이 기능 테스트 스위트
function RegressionTestSuite()
    TestCardPlay()
    TestMinionSummon()
    TestCombatSystem()
    TestTurnManagement()
    TestDeckManagement()
    
    log("회귀 테스트 완료")
end
```

## 성능 테스트

### 대용량 데이터 처리
```lua
-- 많은 카드 처리 성능 테스트
function TestPerformanceWithManyCards()
    local startTime = _DateTime:GetTime()
    
    for i = 1, 1000 do
        local card = CreateTestCard(i)
        player:AddCard(card)
    end
    
    local endTime = _DateTime:GetTime()
    log(string.format("1000장 카드 처리 시간: %f초", endTime - startTime))
end
```

### 메모리 누수 검사
```lua
-- 객체 생성/해제 추적
local objectCount = 0

function CreateTrackedObject()
    objectCount = objectCount + 1
    local obj = CreateObject()
    obj.destroy = function()
        objectCount = objectCount - 1
        DestroyObject(obj)
    end
    return obj
end

function CheckMemoryLeak()
    log(string.format("현재 활성 객체 수: %d", objectCount))
end
```

## 테스트 자동화

### 단위 테스트 프레임워크
```lua
local TestFramework = {}

function TestFramework:Assert(condition, message)
    if not condition then
        error("테스트 실패: " .. (message or "조건 불만족"))
    end
end

function TestFramework:RunTest(testFunction, testName)
    log("테스트 시작: " .. testName)
    
    local success, result = pcall(testFunction)
    
    if success then
        log("테스트 성공: " .. testName)
    else
        log("테스트 실패: " .. testName .. " - " .. tostring(result))
    end
end
```

### 통합 테스트 실행
```lua
-- 전체 테스트 실행
function RunAllTests()
    TestFramework:RunTest(TestCardSystem, "카드 시스템")
    TestFramework:RunTest(TestDuelSystem, "듀얼 시스템")
    TestFramework:RunTest(TestUISystem, "UI 시스템")
    TestFramework:RunTest(TestNetworking, "네트워크 시스템")
end
```

## 디버깅 도구 활용

### 개발자 명령어 확장
```lua
-- 디버깅용 명령어 추가
Developer.commands["/debug"] = function(args)
    local debugInfo = {
        playerCount = _UserService:GetPlayerCount(),
        gameTime = _DateTime:GetTime(),
        memoryUsage = GetMemoryUsage()
    }
    
    for key, value in pairs(debugInfo) do
        log(string.format("%s: %s", key, tostring(value)))
    end
end
```

## 베스트 프랙티스

### 로그 레벨 관리
```lua
local LogLevel = {
    DEBUG = 1,
    INFO = 2, 
    WARNING = 3,
    ERROR = 4
}

function LogWithLevel(level, message)
    if CURRENT_LOG_LEVEL <= level then
        log(string.format("[%s] %s", GetLogLevelName(level), message))
    end
end
```

### 테스트 데이터 관리
```lua
-- 테스트 전용 데이터 생성
function CreateTestCharacter()
    local testChar = Character:new()
    testChar.name = "TestPlayer"
    testChar.meso = 10000
    testChar.level = 1
    return testChar
end
```

이 디버깅과 테스트 가이드를 활용하면 메이플 듀얼 개발 과정에서 발생하는 다양한 문제들을 효과적으로 발견하고 해결할 수 있으며, 게임의 안정성과 품질을 크게 향상시킬 수 있습니다.
