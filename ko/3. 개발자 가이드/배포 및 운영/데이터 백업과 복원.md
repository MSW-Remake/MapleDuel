# 데이터 백업과 복원

## 개요

메이플 듀얼에서 플레이어 데이터의 안전한 백업과 복원은 서비스 운영의 핵심입니다. 이 가이드는 MapleStory Worlds 플랫폼에서의 데이터 구조 이해, 백업 전략, 무결성 검증, 그리고 데이터 복원 절차를 상세히 설명합니다.

## 데이터 구조 이해

### 플레이어 데이터 계층 구조
```lua
-- Character.mlua의 주요 데이터 필드
local CHARACTER_DATA_STRUCTURE = {
    -- 기본 정보
    basic = {
        "name",           -- 캐릭터 이름
        "level",          -- 레벨
        "exp",            -- 경험치
        "meso",           -- 게임 화폐
        "rank",           -- 랭크
        "job",            -- 직업
        "createdAt",      -- 생성 시간
        "lastLoginAt"     -- 마지막 로그인
    },
    
    -- 카드 컬렉션
    collection = {
        "cardCollection", -- 보유 카드 목록
        "cardCount",      -- 카드별 개수
        "newCards"        -- 새로 획득한 카드
    },
    
    -- 덱 정보
    decks = {
        "deckArray",      -- 덱 목록
        "deckIndex",      -- 현재 선택된 덱 인덱스
        "deckJob"         -- 덱 직업
    },
    
    -- 통계 및 기록
    stats = {
        "winCount",       -- 승리 횟수
        "loseCount",      -- 패배 횟수
        "totalGameCount", -- 총 게임 수
        "maxWinStreak",   -- 최대 연승
        "achievements"    -- 업적
    },
    
    -- 설정
    preferences = {
        "soundVolume",    -- 사운드 볼륨
        "musicVolume",    -- 음악 볼륨
        "autoEndTurn",    -- 자동 턴 종료
        "tutorialComplete" -- 튜토리얼 완료 여부
    }
}
```

### 데이터 저장 방식
```lua
-- Character.mlua의 데이터 저장 메서드
@ExecSpace("ServerOnly")
method void SaveData()
    local saveData = {
        version = DATA_VERSION,
        timestamp = _DateTime:GetTime(),
        
        -- 기본 정보
        name = self.name,
        level = self.level,
        exp = self.exp,
        meso = self.meso,
        rank = self.rank,
        job = self.job,
        
        -- 컬렉션 데이터
        cardCollection = self:SerializeCollection(),
        deckArray = self:SerializeDecks(),
        
        -- 통계 데이터
        stats = self:SerializeStats(),
        
        -- 설정 데이터
        preferences = self:SerializePreferences(),
        
        -- 체크섬
        checksum = self:CalculateChecksum()
    }
    
    -- MapleStory Worlds 데이터 서비스에 저장
    _DataService:SaveUserData(self.Entity.PlayerEntity.UserId, saveData)
end

-- 컬렉션 직렬화
method table SerializeCollection()
    local serialized = {}
    
    for cardName, count in pairs(self.cardCollection) do
        serialized[cardName] = {
            count = count,
            firstObtained = self.cardFirstObtained[cardName],
            variants = self.cardVariants[cardName] or {}
        }
    end
    
    return serialized
end

-- 덱 직렬화
method table SerializeDecks()
    local serialized = {}
    
    for i, deck in ipairs(self.deckArray) do
        if deck then
            serialized[i] = {
                cards = deck.cards,
                job = deck.job,
                name = deck.name,
                createdAt = deck.createdAt,
                lastModified = deck.lastModified
            }
        end
    end
    
    return serialized
end
```

## 백업 전략

### 자동 백업 시스템
```lua
-- 자동 백업 스케줄러
@Component
script BackupManager extends Component
    property integer backupInterval = 300 -- 5분마다
    property integer maxBackupFiles = 24  -- 최대 24개 보관 (2시간분)
    
    @ExecSpace("ServerOnly")
    method void OnBeginPlay()
        self:StartAutoBackup()
    end
    
    method void StartAutoBackup()
        _TimerService:SetTimerLoop(function()
            self:PerformAutoBackup()
        end, self.backupInterval)
    end
    
    method void PerformAutoBackup()
        local allCharacters = _UserService:GetAllCharacters()
        
        for _, character in ipairs(allCharacters) do
            if character:IsDataModified() then
                self:BackupCharacterData(character)
                character:MarkDataClean()
            end
        end
    end
end
```

### 백업 데이터 압축
```lua
-- 백업 데이터 압축 및 저장
method void BackupCharacterData(Character character)
    local backupData = {
        userId = character.Entity.PlayerEntity.UserId,
        timestamp = _DateTime:GetTime(),
        dataVersion = DATA_VERSION,
        
        -- 플레이어 데이터
        characterData = character:SerializeForBackup(),
        
        -- 메타데이터
        metadata = {
            backupReason = "auto", -- auto, manual, critical
            gameVersion = GAME_VERSION,
            serverInfo = self:GetServerInfo()
        }
    }
    
    -- 데이터 압축
    local compressedData = self:CompressData(backupData)
    
    -- 백업 파일명 생성
    local backupFileName = string.format("backup_%s_%d.dat", 
        character.Entity.PlayerEntity.UserId, 
        _DateTime:GetTime())
    
    -- 클라우드 스토리지에 저장
    _CloudStorage:SaveBackup(backupFileName, compressedData)
    
    -- 로컬 백업 로그 업데이트
    self:UpdateBackupLog(character.Entity.PlayerEntity.UserId, backupFileName)
end

method string CompressData(table data)
    local jsonString = _MSON:Encode(data)
    return _CompressionService:Compress(jsonString, "gzip")
end
```

### 차등 백업 (Differential Backup)
```lua
-- 변경된 데이터만 백업하는 차등 백업
method table CreateDifferentialBackup(Character character)
    local currentData = character:SerializeForBackup()
    local lastBackup = self:GetLastBackupData(character.Entity.PlayerEntity.UserId)
    
    if not lastBackup then
        -- 첫 백업은 전체 백업
        return currentData
    end
    
    local differences = {}
    
    -- 데이터 비교 및 변경사항 추출
    for key, value in pairs(currentData) do
        if not self:DataEquals(lastBackup[key], value) then
            differences[key] = {
                old = lastBackup[key],
                new = value,
                timestamp = _DateTime:GetTime()
            }
        end
    end
    
    return {
        type = "differential",
        baseBackupId = lastBackup.backupId,
        changes = differences,
        timestamp = _DateTime:GetTime()
    }
end

method boolean DataEquals(any data1, any data2)
    if type(data1) ~= type(data2) then
        return false
    end
    
    if type(data1) == "table" then
        for k, v in pairs(data1) do
            if not self:DataEquals(v, data2[k]) then
                return false
            end
        end
        for k, v in pairs(data2) do
            if data1[k] == nil then
                return false
            end
        end
        return true
    else
        return data1 == data2
    end
end
```

## 데이터 무결성 검증

### 체크섬 검증
```lua
-- 데이터 무결성을 위한 체크섬 계산
method string CalculateChecksum(table data)
    local dataString = _MSON:Encode(data)
    return _CryptographyService:ComputeHash(dataString, "SHA256")
end

-- 백업 데이터 검증
method boolean VerifyBackupIntegrity(table backupData)
    local storedChecksum = backupData.checksum
    backupData.checksum = nil -- 체크섬 제외하고 계산
    
    local calculatedChecksum = self:CalculateChecksum(backupData)
    
    return storedChecksum == calculatedChecksum
end

-- 데이터 일관성 검사
method table ValidateDataConsistency(table characterData)
    local issues = {}
    
    -- 기본 데이터 유효성 검사
    if not characterData.name or characterData.name == "" then
        table.insert(issues, "Invalid character name")
    end
    
    if characterData.meso < 0 then
        table.insert(issues, "Negative meso value")
    end
    
    if characterData.level < 1 or characterData.level > MAX_LEVEL then
        table.insert(issues, "Invalid character level")
    end
    
    -- 컬렉션 데이터 검증
    local validCardNames = self.cardManager:GetAllValidCardNames()
    for cardName, data in pairs(characterData.cardCollection) do
        if not table.contains(validCardNames, cardName) then
            table.insert(issues, string.format("Invalid card: %s", cardName))
        end
        
        if data.count < 0 or data.count > MAX_CARD_COUNT then
            table.insert(issues, string.format("Invalid card count for %s: %d", cardName, data.count))
        end
    end
    
    -- 덱 데이터 검증
    for i, deck in ipairs(characterData.deckArray) do
        if deck then
            local deckIssues = self:ValidateDeck(deck)
            for _, issue in ipairs(deckIssues) do
                table.insert(issues, string.format("Deck %d: %s", i, issue))
            end
        end
    end
    
    return issues
end
```

### 데이터 복구 가능성 체크
```lua
method table CheckDataRecovery(string userId)
    local backupHistory = self:GetBackupHistory(userId)
    local recoveryOptions = {}
    
    for _, backup in ipairs(backupHistory) do
        local isValid = self:TestBackupRestoration(backup, true) -- 테스트 모드
        
        table.insert(recoveryOptions, {
            backupId = backup.id,
            timestamp = backup.timestamp,
            dataVersion = backup.dataVersion,
            isRestorable = isValid.success,
            issues = isValid.issues or {},
            dataSize = backup.size
        })
    end
    
    -- 복구 우선순위로 정렬
    table.sort(recoveryOptions, function(a, b)
        if a.isRestorable ~= b.isRestorable then
            return a.isRestorable -- 복구 가능한 것 우선
        end
        return a.timestamp > b.timestamp -- 최신 것 우선
    end)
    
    return recoveryOptions
end
```

## 데이터 복원 절차

### 기본 복원 프로세스
```lua
-- 데이터 복원 메인 메서드
method table RestoreCharacterData(string userId, string backupId)
    local restoreResult = {
        success = false,
        errors = {},
        warnings = {},
        restoredData = nil
    }
    
    -- 1단계: 백업 파일 검증
    local backupData = self:LoadBackupData(backupId)
    if not backupData then
        table.insert(restoreResult.errors, "Backup file not found")
        return restoreResult
    end
    
    -- 2단계: 무결성 검증
    if not self:VerifyBackupIntegrity(backupData) then
        table.insert(restoreResult.errors, "Backup integrity check failed")
        return restoreResult
    end
    
    -- 3단계: 데이터 일관성 검사
    local consistencyIssues = self:ValidateDataConsistency(backupData.characterData)
    if #consistencyIssues > 0 then
        -- 심각한 문제가 있는지 확인
        local criticalIssues = self:FilterCriticalIssues(consistencyIssues)
        if #criticalIssues > 0 then
            restoreResult.errors = criticalIssues
            return restoreResult
        else
            restoreResult.warnings = consistencyIssues
        end
    end
    
    -- 4단계: 현재 데이터 백업 (복원 실패 시를 위해)
    local character = _UserService:GetCharacterByUserId(userId)
    if character then
        self:CreateEmergencyBackup(character, "pre_restore")
    end
    
    -- 5단계: 데이터 복원 실행
    local success, error = pcall(function()
        self:ApplyRestoredData(userId, backupData.characterData)
    end)
    
    if success then
        restoreResult.success = true
        restoreResult.restoredData = backupData.characterData
        
        -- 복원 로그 기록
        self:LogDataRestore(userId, backupId, "SUCCESS")
    else
        table.insert(restoreResult.errors, "Restore execution failed: " .. tostring(error))
        
        -- 실패 시 롤백
        self:RollbackRestore(userId)
        self:LogDataRestore(userId, backupId, "FAILED", error)
    end
    
    return restoreResult
end
```

### 선택적 복원
```lua
-- 특정 데이터만 선택적으로 복원
method table PartialRestore(string userId, string backupId, table restoreOptions)
    local backupData = self:LoadBackupData(backupId)
    local character = _UserService:GetCharacterByUserId(userId)
    
    if not character then
        return {success = false, error = "Character not found"}
    end
    
    local restoredFields = {}
    
    -- 컬렉션 복원
    if restoreOptions.restoreCollection then
        character.cardCollection = backupData.characterData.cardCollection
        character.cardCount = backupData.characterData.cardCount
        table.insert(restoredFields, "collection")
    end
    
    -- 덱 복원
    if restoreOptions.restoreDecks then
        character.deckArray = self:DeserializeDecks(backupData.characterData.deckArray)
        character.deckIndex = backupData.characterData.deckIndex
        table.insert(restoredFields, "decks")
    end
    
    -- 통계 복원
    if restoreOptions.restoreStats then
        character.winCount = backupData.characterData.winCount
        character.loseCount = backupData.characterData.loseCount
        character.totalGameCount = backupData.characterData.totalGameCount
        table.insert(restoredFields, "stats")
    end
    
    -- 메소/레벨 복원
    if restoreOptions.restoreProgress then
        character.meso = backupData.characterData.meso
        character.level = backupData.characterData.level
        character.exp = backupData.characterData.exp
        table.insert(restoredFields, "progress")
    end
    
    -- 변경사항 저장
    character:SaveData()
    
    return {
        success = true,
        restoredFields = restoredFields,
        timestamp = _DateTime:GetTime()
    }
end
```

### 자동 복구 시스템
```lua
-- 데이터 손상 감지 시 자동 복구
method void AutoRecovery(Character character)
    local issues = self:ValidateDataConsistency(character:SerializeForBackup())
    
    if #issues > 0 then
        -- 복구 시도
        local recoveryOptions = self:CheckDataRecovery(character.Entity.PlayerEntity.UserId)
        
        for _, option in ipairs(recoveryOptions) do
            if option.isRestorable then
                local restoreResult = self:RestoreCharacterData(
                    character.Entity.PlayerEntity.UserId, 
                    option.backupId
                )
                
                if restoreResult.success then
                    self:NotifyAutoRecovery(character, option.backupId)
                    break
                end
            end
        end
    end
end

method void NotifyAutoRecovery(Character character, string backupId)
    -- 플레이어에게 자동 복구 알림
    local message = string.format(
        "데이터 무결성 문제를 발견하여 %s 백업으로 자동 복구했습니다.",
        _DateTime:FormatTime(self:GetBackupTimestamp(backupId))
    )
    
    character:SendSystemMessage(message)
    
    -- 관리자에게도 알림
    self:NotifyAdminAutoRecovery(character.Entity.PlayerEntity.UserId, backupId)
end
```

## 백업 데이터 관리

### 백업 파일 정리
```lua
-- 오래된 백업 파일 정리
method void CleanupOldBackups()
    local retentionDays = 30 -- 30일 보관
    local cutoffTime = _DateTime:GetTime() - (retentionDays * 24 * 3600)
    
    local allBackups = _CloudStorage:ListBackups()
    
    for _, backup in ipairs(allBackups) do
        if backup.timestamp < cutoffTime then
            -- 중요한 백업인지 확인
            if not self:IsImportantBackup(backup) then
                _CloudStorage:DeleteBackup(backup.id)
                self:LogBackupDeletion(backup.id, "expired")
            end
        end
    end
end

method boolean IsImportantBackup(table backup)
    -- 주요 마일스톤 백업 (레벨업, 랭크업 등)
    if backup.metadata.milestone then
        return true
    end
    
    -- 수동 백업
    if backup.metadata.backupReason == "manual" then
        return true
    end
    
    -- 복원에 사용된 백업
    if backup.metadata.usedForRestore then
        return true
    end
    
    return false
end
```

### 백업 모니터링
```lua
-- 백업 상태 모니터링
method table GetBackupSystemStatus()
    local status = {
        lastBackupTime = self:GetLastBackupTime(),
        totalBackups = self:GetTotalBackupCount(),
        failedBackups = self:GetFailedBackupCount(),
        storageUsed = self:GetBackupStorageUsage(),
        healthScore = 0
    }
    
    -- 건강도 점수 계산
    local timeSinceLastBackup = _DateTime:GetTime() - status.lastBackupTime
    
    if timeSinceLastBackup < 600 then -- 10분 이내
        status.healthScore += 30
    elseif timeSinceLastBackup < 1800 then -- 30분 이내  
        status.healthScore += 20
    else
        status.healthScore += 10
    end
    
    local failureRate = status.failedBackups / math.max(status.totalBackups, 1)
    if failureRate < 0.01 then -- 1% 미만
        status.healthScore += 40
    elseif failureRate < 0.05 then -- 5% 미만
        status.healthScore += 30
    else
        status.healthScore += 10
    end
    
    if status.storageUsed < 0.8 then -- 80% 미만
        status.healthScore += 30
    elseif status.storageUsed < 0.95 then -- 95% 미만
        status.healthScore += 20
    else
        status.healthScore += 5
    end
    
    return status
end
```

## 운영 도구

### 관리자 복원 도구
```lua
-- 관리자용 데이터 복원 인터페이스
@AdminOnly
method table AdminRestoreData(string userId, table options)
    -- 관리자 권한 확인
    if not self:IsAdmin(_UserService.LocalPlayer) then
        return {success = false, error = "Insufficient permissions"}
    end
    
    -- 복원 옵션 검증
    local validOptions = self:ValidateRestoreOptions(options)
    if not validOptions.isValid then
        return {success = false, errors = validOptions.errors}
    end
    
    -- 복원 실행
    local result = self:RestoreCharacterData(userId, options.backupId)
    
    -- 관리자 로그 기록
    self:LogAdminAction(_UserService.LocalPlayer, "DATA_RESTORE", {
        targetUserId = userId,
        backupId = options.backupId,
        result = result.success
    })
    
    return result
end
```

### 데이터 마이그레이션
```lua
-- 데이터 구조 변경 시 마이그레이션
method void MigrateUserData(string userId, string fromVersion, string toVersion)
    local character = _UserService:GetCharacterByUserId(userId)
    if not character then return end
    
    local migrator = self.migrators[fromVersion .. "_to_" .. toVersion]
    if not migrator then
        error("No migrator found for " .. fromVersion .. " to " .. toVersion)
    end
    
    -- 마이그레이션 전 백업
    self:CreateEmergencyBackup(character, "pre_migration")
    
    -- 마이그레이션 실행
    local success, result = pcall(migrator.migrate, character)
    
    if success then
        character.dataVersion = toVersion
        character:SaveData()
        self:LogDataMigration(userId, fromVersion, toVersion, "SUCCESS")
    else
        self:LogDataMigration(userId, fromVersion, toVersion, "FAILED", result)
        error("Migration failed: " .. tostring(result))
    end
end
```

이 백업과 복원 시스템을 통해 메이플 듀얼 플레이어들의 소중한 게임 데이터를 안전하게 보호하고, 문제 발생 시 신속한 복구가 가능합니다.
