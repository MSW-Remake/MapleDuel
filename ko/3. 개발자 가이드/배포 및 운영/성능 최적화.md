# 성능 최적화 가이드

## 개요

메이플 듀얼의 성능 최적화는 모바일 환경에서의 원활한 게임 플레이를 보장하는 핵심 요소입니다. 이 가이드는 오브젝트 풀링, 리소스 관리, 네트워크 최적화, 메모리 관리 등 다양한 최적화 기법을 제시합니다.

## 오브젝트 풀링 최적화

### 카드 오브젝트 풀링
```lua
-- Duel.mlua의 카드 풀링 시스템
@Component  
script Duel extends Component
    property table cardPool = {}
    property table minionPool = {}
    property integer maxPoolSize = 50
    
    method Card GetPooledCard()
        if #self.cardPool > 0 then
            local card = table.remove(self.cardPool)
            card:Reset() -- 카드 상태 초기화
            return card
        else
            -- 풀에 카드가 없으면 새로 생성
            return self:CreateNewCard()
        end
    end
    
    method void ReturnCardToPool(Card card)
        if #self.cardPool < self.maxPoolSize then
            card:Hide()
            card.isActive = false
            table.insert(self.cardPool, card)
        else
            -- 풀이 가득 찬 경우 카드 파괴
            card:Destroy()
        end
    end
    
    method Card CreateNewCard()
        local cardEntity = _SpawnService:SpawnByModelId(
            _EntryService:GetModelIdByName("Card"), 
            "Card"
        )
        local card = cardEntity:GetComponentByType(Card)
        return card
    end
end
```

### 미니언 오브젝트 풀링
```lua
-- 미니언 풀링 최적화
method Minion GetPooledMinion(string minionName)
    local pool = self.minionPools[minionName]
    if not pool then
        pool = {}
        self.minionPools[minionName] = pool
    end
    
    if #pool > 0 then
        local minion = table.remove(pool)
        minion:Reset()
        minion:Show()
        return minion
    else
        return self:CreateNewMinion(minionName)
    end
end

method void ReturnMinionToPool(Minion minion)
    local minionName = minion.name
    local pool = self.minionPools[minionName]
    
    if #pool < MAX_MINION_POOL_SIZE then
        minion:Hide()
        minion:ResetToDefaults()
        table.insert(pool, minion)
    else
        minion:Destroy()
    end
end
```

### 이펙트 오브젝트 풀링
```lua
-- Effect.mlua 풀링 최적화
@Logic
script Effect extends Logic
    property table effectPool = {}
    
    @ExecSpace("ClientOnly")
    method Entity GetPooledEffect(string effectName)
        local pool = self.effectPool[effectName]
        if not pool then
            pool = {}
            self.effectPool[effectName] = pool
        end
        
        if #pool > 0 then
            local effect = table.remove(pool)
            effect.IsActive = true
            return effect
        else
            return self:CreateEffect(effectName)
        end
    end
    
    @ExecSpace("ClientOnly")
    method void ReturnEffectToPool(Entity effect, string effectName)
        effect.IsActive = false
        effect.TransformComponent.WorldPosition = Vector3(0, -1000, 0) -- 화면 밖으로
        
        local pool = self.effectPool[effectName]
        if #pool < MAX_EFFECT_POOL_SIZE then
            table.insert(pool, effect)
        else
            _SpawnService:Destroy(effect)
        end
    end
end
```

## 메모리 관리 최적화

### 가비지 컬렉션 최적화
```lua
-- 메모리 사용량 모니터링 및 최적화
@Logic
script MemoryManager extends Logic
    property number lastGCTime = 0
    property number gcThreshold = 50 * 1024 * 1024 -- 50MB
    
    method void OnUpdate()
        local currentMemory = self:GetMemoryUsage()
        local currentTime = _DateTime:GetTime()
        
        -- 메모리 사용량이 임계값을 초과하거나 30초마다 GC 수행
        if currentMemory > self.gcThreshold or 
           currentTime - self.lastGCTime > 30 then
            self:OptimizeMemory()
            self.lastGCTime = currentTime
        end
    end
    
    method void OptimizeMemory()
        -- 사용하지 않는 트위너 정리
        self:CleanupTweeners()
        
        -- 타이머 정리
        self:CleanupTimers()
        
        -- 이벤트 리스너 정리
        self:CleanupEventListeners()
        
        -- 텍스처 캐시 정리
        self:CleanupTextureCache()
        
        -- 강제 가비지 컬렉션
        collectgarbage("collect")
    end
    
    method void CleanupTweeners()
        for entity, tweeners in pairs(_GlobalTweeners) do
            if not isvalid(entity) then
                for _, tweener in ipairs(tweeners) do
                    tweener:Destroy()
                end
                _GlobalTweeners[entity] = nil
            end
        end
    end
end
```

### 텍스처 메모리 최적화
```lua
-- 텍스처 로딩 및 해제 최적화
method void OptimizeTextureMemory()
    -- 화면에 보이지 않는 카드들의 텍스처 해제
    for _, card in ipairs(self:GetAllCards()) do
        if not card:IsVisible() and card.texture then
            _ResourceService:UnloadTexture(card.texture)
            card.texture = nil
        end
    end
    
    -- 사용하지 않는 UI 텍스처 해제
    for moduleName, module in pairs(self.uiManager.modules) do
        if not module.isOpen then
            module:UnloadTextures()
        end
    end
end
```

## 렌더링 최적화

### 배칭(Batching) 최적화
```lua
-- UI 요소들의 드로우 콜 최적화
method void OptimizeUIRendering()
    -- 같은 아틀라스를 사용하는 UI 요소들을 함께 렌더링
    local sortingGroups = {}
    
    for _, uiElement in ipairs(self:GetActiveUIElements()) do
        local atlas = uiElement:GetAtlasName()
        if not sortingGroups[atlas] then
            sortingGroups[atlas] = {}
        end
        table.insert(sortingGroups[atlas], uiElement)
    end
    
    -- 그룹별로 정렬 레이어 설정
    local layerIndex = 0
    for atlas, elements in pairs(sortingGroups) do
        for _, element in ipairs(elements) do
            element:SetSortingLayer("UI", layerIndex)
        end
        layerIndex += 1
    end
end
```

### LOD (Level of Detail) 시스템
```lua
-- 거리에 따른 디테일 조정
method void ApplyLOD(Entity entity, number distanceFromCamera)
    local lodLevel = self:CalculateLODLevel(distanceFromCamera)
    
    if lodLevel == 0 then
        -- 고품질 (가까운 거리)
        entity:SetTextureQuality("High")
        entity:SetAnimationQuality("High")
    elseif lodLevel == 1 then
        -- 중품질
        entity:SetTextureQuality("Medium")
        entity:SetAnimationQuality("Medium")
    else
        -- 저품질 (먼 거리)
        entity:SetTextureQuality("Low")
        entity:SetAnimationQuality("Low")
    end
end

method integer CalculateLODLevel(number distance)
    if distance < 5 then return 0
    elseif distance < 15 then return 1
    else return 2 end
end
```

## 네트워크 최적화

### 데이터 패킷 최적화
```lua
-- CommandManager의 네트워크 최적화
method void OptimizeNetworking()
    -- 명령어 배칭 - 여러 명령어를 한 번에 전송
    if #self.pendingCommands > 1 then
        local batchedCommand = {
            type = "BATCH",
            commands = self.pendingCommands,
            timestamp = _DateTime:GetTime()
        }
        
        _Server:SendCommand(batchedCommand)
        self.pendingCommands = {}
    end
end

-- 데이터 압축
method table CompressGameData(table data)
    -- 중복 데이터 제거
    local compressed = {}
    local references = {}
    
    for key, value in pairs(data) do
        if references[value] then
            compressed[key] = {type = "ref", id = references[value]}
        else
            local refId = #references + 1
            references[value] = refId
            compressed[key] = {type = "data", value = value, id = refId}
        end
    end
    
    return compressed
end
```

### 예측적 로딩
```lua
-- 플레이어 행동 예측을 통한 사전 로딩
method void PredictiveLoading(Player player)
    -- 플레이어의 손패를 분석하여 사용할 가능성이 높은 카드 예측
    local likelyCards = self:AnalyzeHandForLikelyPlays(player.hand)
    
    for _, cardName in ipairs(likelyCards) do
        -- 카드 이펙트 미리 로딩
        local cardData = self.cardManager:GetCardData(cardName)
        if cardData.effectName then
            _ResourceService:PreloadEffect(cardData.effectName)
        end
        
        -- 카드 사운드 미리 로딩
        if cardData.soundRUID then
            _ResourceService:PreloadSound(cardData.soundRUID)
        end
    end
end

method table AnalyzeHandForLikelyPlays(Hand hand)
    local likelyCards = {}
    local player = hand:GetPlayer()
    
    for _, card in ipairs(hand:GetCards()) do
        -- MP 비용이 현재 MP 이하인 카드들
        if card.cost <= player.mp then
            table.insert(likelyCards, card.name)
        end
    end
    
    return likelyCards
end
```

## 애니메이션 최적화

### 애니메이션 컬링
```lua
-- 화면에 보이지 않는 애니메이션 비활성화
method void OptimizeAnimations()
    for _, entity in ipairs(self:GetAllAnimatedEntities()) do
        if not self:IsEntityVisible(entity) then
            -- 화면 밖 엔티티의 애니메이션 정지
            local animator = entity:GetComponentByType(StateAnimationComponent)
            if animator then
                animator.IsEnabled = false
            end
        else
            -- 화면 내 엔티티의 애니메이션 재개
            local animator = entity:GetComponentByType(StateAnimationComponent)
            if animator then
                animator.IsEnabled = true
            end
        end
    end
end

method boolean IsEntityVisible(Entity entity)
    local bounds = entity:GetBounds()
    local camera = _CameraService.MainCamera
    local frustum = camera:GetFrustum()
    
    return frustum:ContainsBounds(bounds)
end
```

### 애니메이션 품질 동적 조정
```lua
-- 성능에 따른 애니메이션 품질 자동 조정
method void AdjustAnimationQuality()
    local frameRate = self:GetCurrentFrameRate()
    local targetFrameRate = 60
    
    if frameRate < targetFrameRate * 0.8 then -- 48fps 이하
        -- 애니메이션 품질 낮추기
        for _, entity in ipairs(self:GetAllAnimatedEntities()) do
            local animator = entity:GetComponentByType(StateAnimationComponent)
            if animator then
                animator.PlaybackSpeed = 0.5 -- 애니메이션 속도 감소
                animator.UpdateMode = "FrameSkip" -- 프레임 스킵 모드
            end
        end
        
        self.currentQuality = "Low"
    elseif frameRate > targetFrameRate * 0.95 then -- 57fps 이상
        -- 애니메이션 품질 복원
        for _, entity in ipairs(self:GetAllAnimatedEntities()) do
            local animator = entity:GetComponentByType(StateAnimationComponent)
            if animator then
                animator.PlaybackSpeed = 1.0
                animator.UpdateMode = "Normal"
            end
        end
        
        self.currentQuality = "High"
    end
end
```

## UI 최적화

### UI 업데이트 최적화
```lua
-- 필요한 경우에만 UI 업데이트
method void OptimizeUIUpdates()
    -- 더티 플래그 시스템 사용
    for _, module in pairs(self.uiManager.modules) do
        if module.isDirty and module.isVisible then
            module:UpdateUI()
            module.isDirty = false
        end
    end
end

-- 스크롤 뷰 최적화 (가상화)
method void VirtualizeScrollView(ScrollView scrollView)
    local viewportHeight = scrollView:GetViewportHeight()
    local itemHeight = scrollView:GetItemHeight()
    local visibleCount = math.ceil(viewportHeight / itemHeight) + 2 -- 여유분 2개
    
    local scrollPosition = scrollView:GetScrollPosition()
    local firstVisibleIndex = math.floor(scrollPosition / itemHeight)
    
    -- 보이는 범위의 아이템만 활성화
    for i = 1, scrollView:GetTotalItemCount() do
        local item = scrollView:GetItem(i)
        
        if i >= firstVisibleIndex and i < firstVisibleIndex + visibleCount then
            item:SetActive(true)
            item:UpdateContent()
        else
            item:SetActive(false)
        end
    end
end
```

## 데이터베이스 최적화

### 쿼리 최적화
```lua
-- 효율적인 데이터 조회
method table GetOptimizedCardData(table cardNames)
    -- 한 번의 쿼리로 여러 카드 데이터 조회
    local cardDataMap = {}
    local dataSet = _DataService:GetTable("Card")
    
    -- 인덱스를 활용한 빠른 검색
    for _, cardName in ipairs(cardNames) do
        local index = self.cardNameIndex[cardName]
        if index then
            cardDataMap[cardName] = dataSet:GetRow(index)
        end
    end
    
    return cardDataMap
end

-- 데이터 캐싱
method void CacheFrequentData()
    -- 자주 사용되는 데이터를 메모리에 캐시
    self.cachedData = {
        commonCards = self:GetCommonCards(),
        basicDecks = self:GetBasicDecks(),
        uiTexts = self:GetUITexts()
    }
end
```

## 성능 모니터링

### 실시간 성능 추적
```lua
-- 성능 메트릭 수집
@Component
script PerformanceMonitor extends Component
    property table metrics = {}
    
    method void TrackPerformance(string metricName, function func, ...)
        local startTime = _DateTime:GetHighResolutionTime()
        local result = func(...)
        local endTime = _DateTime:GetHighResolutionTime()
        
        local duration = endTime - startTime
        
        if not self.metrics[metricName] then
            self.metrics[metricName] = {
                totalTime = 0,
                callCount = 0,
                maxTime = 0,
                minTime = math.huge
            }
        end
        
        local metric = self.metrics[metricName]
        metric.totalTime += duration
        metric.callCount += 1
        metric.maxTime = math.max(metric.maxTime, duration)
        metric.minTime = math.min(metric.minTime, duration)
        
        return result
    end
    
    method table GetPerformanceReport()
        local report = {}
        
        for metricName, metric in pairs(self.metrics) do
            report[metricName] = {
                averageTime = metric.totalTime / metric.callCount,
                maxTime = metric.maxTime,
                minTime = metric.minTime,
                callCount = metric.callCount,
                totalTime = metric.totalTime
            }
        end
        
        return report
    end
end
```

### 자동 성능 조정
```lua
-- 성능 기반 품질 자동 조정
method void AutoAdjustQuality()
    local performanceScore = self:CalculatePerformanceScore()
    
    if performanceScore < 0.5 then
        -- 낮은 성능: 최적화 모드
        self:EnablePerformanceMode()
    elseif performanceScore > 0.8 then
        -- 높은 성능: 품질 모드
        self:EnableQualityMode()
    end
end

method void EnablePerformanceMode()
    -- 이펙트 품질 감소
    _Effect:SetQuality("Low")
    
    -- 텍스처 해상도 감소
    _ResourceService:SetTextureQuality(0.5)
    
    -- 애니메이션 프레임 레이트 제한
    _AnimationService:SetMaxFrameRate(30)
    
    -- UI 업데이트 주기 증가
    self.uiUpdateInterval = 0.1
end

method void EnableQualityMode()
    -- 이펙트 품질 복원
    _Effect:SetQuality("High")
    
    -- 텍스처 해상도 복원
    _ResourceService:SetTextureQuality(1.0)
    
    -- 애니메이션 프레임 레이트 복원
    _AnimationService:SetMaxFrameRate(60)
    
    -- UI 업데이트 주기 감소
    self.uiUpdateInterval = 0.033
end
```

## 플랫폼별 최적화

### 모바일 최적화
```lua
-- 모바일 디바이스 감지 및 최적화
method void OptimizeForMobile()
    if _DeviceService:IsMobile() then
        -- 배터리 절약 모드
        self:EnableBatterySaver()
        
        -- 터치 최적화
        self:OptimizeTouchInput()
        
        -- 메모리 최적화
        self:AggressiveMemoryCleanup()
    end
end

method void EnableBatterySaver()
    -- 배경 애니메이션 제한
    for _, bgAnimation in ipairs(self:GetBackgroundAnimations()) do
        bgAnimation:SetFrameRate(15) -- 15fps로 제한
    end
    
    -- 파티클 시스템 최적화
    for _, particle in ipairs(self:GetParticleSystems()) do
        particle:SetMaxParticles(particle:GetMaxParticles() * 0.5)
    end
end
```

이러한 성능 최적화 기법들을 종합적으로 적용하면 메이플 듀얼이 다양한 디바이스 환경에서 안정적이고 부드러운 게임 플레이 경험을 제공할 수 있습니다.
