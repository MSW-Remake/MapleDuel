# ê²Œì„ ì§„í–‰ ì œì–´ (TaskManager.mlua)

## ğŸ“‹ ê°œìš”

`TaskManager.mlua`ëŠ” ë©”ì´í”Œ ë“€ì–¼ì—ì„œ ê²Œì„ì˜ ì „ì²´ ì§„í–‰ íë¦„ì„ ì œì–´í•˜ëŠ” ì¤‘ì•™ ê´€ë¦¬ìì…ë‹ˆë‹¤. í„´ì œ ì‹œìŠ¤í…œì˜ ë¼ìš´ë“œì™€ í„´ ê´€ë¦¬, ê²Œì„ ì•¡ì…˜ì˜ ìˆœì°¨ ì‹¤í–‰, íŠ¸ë¦¬ê±° ì‹œìŠ¤í…œ ì—°ë™, ê·¸ë¦¬ê³  ë‹¤ì–‘í•œ ê²Œì„í”Œë ˆì´ ì‘ì—…(ì¹´ë“œ í”Œë ˆì´, ì „íˆ¬, ì†Œí™˜ ë“±)ì˜ ì¡°ìœ¨ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤. ëª¨ë“  ê²Œì„ ì§„í–‰ì€ TaskManagerë¥¼ í†µí•´ ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬ë˜ë©°, ì´ë¥¼ í†µí•´ ë³µì¡í•œ ì¹´ë“œ íš¨ê³¼ì™€ ìƒí˜¸ì‘ìš©ì´ ì˜¬ë°”ë¥¸ ìˆœì„œë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤.

**ê´€ë ¨ íŒŒì¼**: 
- `RootDesk/MyDesk/Components/Managers/TaskManager.mlua`

## ğŸ—ï¸ ê²Œì„ ì§„í–‰ ì œì–´ ì•„í‚¤í…ì²˜

### ì‹œìŠ¤í…œ êµ¬ì¡°

```mermaid
graph TB
    A[TaskManager<br/>ì¤‘ì•™ ê²Œì„ ì§„í–‰ ì œì–´] --> B[í„´ì œ ì‹œìŠ¤í…œ]
    A --> C[ì•¡ì…˜ ì‹¤í–‰ ì‹œìŠ¤í…œ]
    A --> D[ì…€ë ‰í„° ì‹œìŠ¤í…œ]
    A --> E[ë°°ì¹˜ ì²˜ë¦¬ ì‹œìŠ¤í…œ]
    A --> F[íŠ¸ë¦¬ê±° ì—°ë™]
    
    B --> B1[ë¼ìš´ë“œ ê´€ë¦¬<br/>BeginRound/EndRound]
    B --> B2[í„´ ê´€ë¦¬<br/>BeginTurn/EndTurn]
    B --> B3[í”Œë ˆì´ì–´ ìˆœì„œ ì œì–´]
    
    C --> C1[ì¹´ë“œ í”Œë ˆì´ - Play]
    C --> C2[ì „íˆ¬ ì²˜ë¦¬ - Battle]
    C --> C3[ë¯¸ë‹ˆì–¸ ì†Œí™˜ - Summon]
    C --> C4[ë°ë¯¸ì§€ ì²˜ë¦¬ - Damage]
    C --> C5[ì¹´ë“œ ë“œë¡œìš° - Draw]
    
    D --> D1[ìƒì¡´ ìœ ë‹› - liveSelector]
    D --> D2[ìƒíƒœ íš¨ê³¼ë³„ - freezeSelector ë“±]
    D --> D3[íƒœê·¸ë³„ - minionSelector ë“±]
    
    E --> E1[ìˆœì°¨ ì‹¤í–‰ - RunBatch]
    E --> E2[ì§€ì—° ì²˜ë¦¬ - delay]
    E --> E3[ë™ê¸°í™” ëŒ€ê¸°]
```

### í•µì‹¬ í”„ë¡œí¼í‹°

#### ë§¤ë‹ˆì € ì—°ë™
- `duel`: ë“€ì–¼ ì»´í¬ë„ŒíŠ¸ ì°¸ì¡°
- `actionManager`: ì•¡ì…˜ ì‹¤í–‰ ê´€ë¦¬ì
- `commandManager`: ëª…ë ¹ ë™ê¸°í™” ê´€ë¦¬ì
- `triggerManager`: íŠ¸ë¦¬ê±° ì‹œìŠ¤í…œ ê´€ë¦¬ì
- `history`: ê²Œì„ íˆìŠ¤í† ë¦¬ ê¸°ë¡

#### ì‹¤í–‰ ì œì–´
- `delay`: í˜„ì¬ ëˆ„ì ëœ ì§€ì—° ì‹œê°„
- `coreDelayTable`: í•µì‹¬ ì§€ì—° ì‹œê°„ í…Œì´ë¸”

#### ì…€ë ‰í„° ì‹œìŠ¤í…œ
- `validSelector`: ìœ íš¨í•œ ê°ì²´ íŒë³„
- `liveSelector`: ìƒì¡´ ìœ ë‹› íŒë³„
- `openSelector`: ê³µê°œëœ ì¹´ë“œ íŒë³„
- ë‹¤ì–‘í•œ ìƒíƒœë³„/íƒœê·¸ë³„ ì…€ë ‰í„°ë“¤

## ğŸ® 1. í„´ì œ ì‹œìŠ¤í…œ ì œì–´

### ê²Œì„ ì§„í–‰ íë¦„

```mermaid
sequenceDiagram
    participant TM as TaskManager
    participant D as Duel
    participant P1 as Player1
    participant P2 as Player2
    
    TM->>D: BeginRound(roundPlayer) í˜¸ì¶œ
    TM->>TM: ë¼ìš´ë“œ ì‹œì‘ íŠ¸ë¦¬ê±° ë°œë™
    TM->>P1: BeginTurn(player1) í˜¸ì¶œ
    TM->>TM: í„´ ì‹œì‘ íŠ¸ë¦¬ê±° ë°œë™
    
    Note over P1: í”Œë ˆì´ì–´1 í–‰ë™
    P1->>TM: ì¹´ë“œ í”Œë ˆì´ ë˜ëŠ” í„´ ì¢…ë£Œ
    TM->>TM: EndTurn() í˜¸ì¶œ
    TM->>P2: BeginTurn(player2) í˜¸ì¶œ
    
    Note over P2: í”Œë ˆì´ì–´2 í–‰ë™
    P2->>TM: ë¼ìš´ë“œ ì¢…ë£Œ ì„ ì–¸
    TM->>TM: DeclareEndRound() ì²˜ë¦¬
    
    alt ì–‘ í”Œë ˆì´ì–´ ëª¨ë‘ ì¢…ë£Œ ì„ ì–¸
        TM->>TM: EndRound() í˜¸ì¶œ
        TM->>TM: ë‹¤ìŒ ë¼ìš´ë“œ ì‹œì‘
    else í•œìª½ë§Œ ì¢…ë£Œ ì„ ì–¸
        TM->>P1: ê³„ì† ì§„í–‰
    end
```

### ë¼ìš´ë“œ ê´€ë¦¬ ì‹œìŠ¤í…œ

#### BeginRound() ë©”ì»¤ë‹ˆì¦˜
```lua
method void BeginRound(Player roundPlayer)
    local taskName = "BeginRound"
    local args = {}
    local objectArray = {roundPlayer}
    
    -- ë“€ì–¼ ì»´í¬ë„ŒíŠ¸ì— ë¼ìš´ë“œ ì‹œì‘ ì•Œë¦¼
    self.duel:BeginRound(roundPlayer)
    
    -- íŠ¸ë¦¬ê±° ì‹œìŠ¤í…œì— ë¼ìš´ë“œ ì‹œì‘ ì´ë²¤íŠ¸ ì „íŒŒ
    self.triggerManager:InvokeTriggers(objectArray, receiverArray, "BeginRound", args, nil, nil)
    
    -- ì²« ë²ˆì§¸ í„´ ì‹œì‘
    self:BeginTurn(roundPlayer)
end
```

**ë¼ìš´ë“œ ì‹œì‘ ì²˜ë¦¬**:
- ë¼ìš´ë“œ í”Œë ˆì´ì–´ ì„¤ì • ë° UI ì—…ë°ì´íŠ¸
- ë¼ìš´ë“œë³„ íŠ¸ë¦¬ê±° íš¨ê³¼ ë°œë™
- ì²« ë²ˆì§¸ í„´ ìë™ ì‹œì‘

#### EndRound() ë©”ì»¤ë‹ˆì¦˜
```lua
method void EndRound(boolean isTimeout)
    local taskName = "EndRound"
    local args = {isTimeout}
    
    -- í˜„ì¬ í„´ ê°•ì œ ì¢…ë£Œ
    self:EndTurn(isTimeout)
    
    -- ë“€ì–¼ ì»´í¬ë„ŒíŠ¸ì— ë¼ìš´ë“œ ì¢…ë£Œ ì•Œë¦¼
    self.duel:EndRound(isTimeout)
    
    -- ë¼ìš´ë“œ ì¢…ë£Œ íŠ¸ë¦¬ê±° ë°œë™
    self.triggerManager:InvokeTriggers(objectArray, receiverArray, "EndRound", args, nil, nil)
end
```

### í„´ ê´€ë¦¬ ì‹œìŠ¤í…œ

#### BeginTurn() ì„¸ë¶€ ì²˜ë¦¬
```mermaid
graph LR
    A[BeginTurn í˜¸ì¶œ] --> B[í„´ í”Œë ˆì´ì–´ ì„¤ì •]
    B --> C[MP ì¦ê°€]
    C --> D[ì¹´ë“œ ë“œë¡œìš°]
    D --> E[í„´ ì‹œì‘ íŠ¸ë¦¬ê±°]
    E --> F[UI ì—…ë°ì´íŠ¸]
    F --> G[í”Œë ˆì´ì–´ ì…ë ¥ ëŒ€ê¸°]
```

```lua
method void BeginTurn(Player turnPlayer)
    local taskName = "BeginTurn"
    local args = {}
    local objectArray = {turnPlayer}
    
    -- ë“€ì–¼ì— í„´ í”Œë ˆì´ì–´ ì„¤ì •
    self.duel.turnPlayer = turnPlayer
    
    -- íŠ¸ë¦¬ê±° ì‹œìŠ¤í…œì— í„´ ì‹œì‘ ì•Œë¦¼
    self.triggerManager:InvokeTriggers(objectArray, receiverArray, "BeginTurn", args, nil, nil)
    
    -- ìë™ ì²˜ë¦¬ (MP ì¦ê°€, ì¹´ë“œ ë“œë¡œìš° ë“±)
    -- ì´ ë¶€ë¶„ì€ íŠ¸ë¦¬ê±°ë¥¼ í†µí•´ ì²˜ë¦¬ë¨
end
```

#### ë¼ìš´ë“œ ì¢…ë£Œ ì„ ì–¸ ì‹œìŠ¤í…œ
```mermaid
sequenceDiagram
    participant P1 as Player1
    participant TM as TaskManager
    participant P2 as Player2
    
    P1->>TM: DeclareEndRound() í˜¸ì¶œ
    TM->>P1: isEndRoundDeclared = true ì„¤ì •
    
    alt Player2ë„ ì´ë¯¸ ì„ ì–¸í•¨
        TM->>TM: EndRound() ì¦‰ì‹œ ì‹¤í–‰
        TM->>TM: ë‹¤ìŒ ë¼ìš´ë“œ ì‹œì‘ ë˜ëŠ” ê²Œì„ ì¢…ë£Œ
    else Player2ê°€ ì•„ì§ ì„ ì–¸í•˜ì§€ ì•ŠìŒ
        TM->>P2: í„´ ê³„ì† ì§„í–‰
        Note over P2: Player2ì˜ ì„ íƒ ëŒ€ê¸°
    end
```

## âš”ï¸ 2. ê²Œì„ ì•¡ì…˜ ì‹¤í–‰ ì‹œìŠ¤í…œ

### ë°°ì¹˜ ì²˜ë¦¬ ì‹œìŠ¤í…œ (RunBatch)

#### ìˆœì°¨ ì‹¤í–‰ ë©”ì»¤ë‹ˆì¦˜
```lua
method void RunBatch(table objectArray, string taskName, table args, table eachArgs, string actionName, number interval)
    if _Table:IsEmpty(objectArray) then
        return
    end
    
    -- ê° ê°ì²´ì— ëŒ€í•´ ìˆœì°¨ì ìœ¼ë¡œ ì‘ì—… ì‹¤í–‰
    for i, object in ipairs(objectArray) do
        -- ê°œë³„ ì¸ìˆ˜ê°€ ìˆëŠ” ê²½ìš° ì‚¬ìš©
        local currentArgs = eachArgs and eachArgs[i] or args
        
        -- ë©”ì„œë“œ í˜¸ì¶œ
        _Util:Call(object, taskName, currentArgs)
        
        -- ì•¡ì…˜ ì• ë‹ˆë©”ì´ì…˜ (í´ë¼ì´ì–¸íŠ¸ ì¸¡)
        if actionName and self:IsClient() then
            object:Animate(actionName)
        end
        
        -- ê°„ê²© ëŒ€ê¸° (ë§ˆì§€ë§‰ ê°ì²´ ì œì™¸)
        if interval and i < #objectArray then
            if self:IsClient() then
                wait(interval)
            end
            self:AddDelay(interval)
        end
    end
end
```

**ë°°ì¹˜ ì²˜ë¦¬ì˜ ì¥ì **:
- **ì¼ê´€ì„±**: ë™ì¼í•œ íŒ¨í„´ìœ¼ë¡œ ëª¨ë“  ê²Œì„ ì•¡ì…˜ ì²˜ë¦¬
- **ë™ê¸°í™”**: ì„œë²„-í´ë¼ì´ì–¸íŠ¸ ê°„ ì •í™•í•œ íƒ€ì´ë° ë³´ì¥
- **ì‹œê°ì  í”¼ë“œë°±**: ì• ë‹ˆë©”ì´ì…˜ê³¼ ì§€ì—° ì‹œê°„ì„ í†µí•œ ìì—°ìŠ¤ëŸ¬ìš´ ì—°ì¶œ

### ì£¼ìš” ê²Œì„ ì•¡ì…˜ë“¤

#### ì¹´ë“œ í”Œë ˆì´ (Play)
```mermaid
sequenceDiagram
    participant P as Player
    participant TM as TaskManager
    participant C as Card
    participant TR as TriggerManager
    
    P->>TM: Play(card, targets) ìš”ì²­
    TM->>C: Play() ë©”ì„œë“œ í˜¸ì¶œ
    C->>C: ì¹´ë“œ íš¨ê³¼ ì‹¤í–‰
    TM->>TR: Play íŠ¸ë¦¬ê±° ë°œë™
    TR->>TR: ì—°ì‡„ íŠ¸ë¦¬ê±° ì²˜ë¦¬
    TM->>TM: í„´ ì¢…ë£Œ ì²˜ë¦¬ (í•„ìš” ì‹œ)
```

#### ì „íˆ¬ ì²˜ë¦¬ (Battle)
```lua
method void Battle(table attackerArray, table targetArray)
    local taskName = "Battle"
    local args = {}
    
    -- ê³µê²©ìì™€ ëŒ€ìƒì„ ë§¤ì¹­í•˜ì—¬ ì „íˆ¬ ì²˜ë¦¬
    for i, attacker in ipairs(attackerArray) do
        local target = targetArray[i] or targetArray[1]  -- ëŒ€ìƒ ë§¤ì¹­
        
        if isvalid(target) and not target.isDead then
            -- ì‹¤ì œ ì „íˆ¬ ë¡œì§ ì‹¤í–‰
            local battleResult = target:Damage(attacker, attacker:GetFinalAtk())
            
            -- ì „íˆ¬ ê²°ê³¼ì— ë”°ë¥¸ ì¶”ê°€ ì²˜ë¦¬
            if battleResult.damage > 0 then
                self.history:AddThisGameDamage(attacker.player, battleResult.damage)
            end
        end
    end
    
    -- ì „íˆ¬ íŠ¸ë¦¬ê±° ë°œë™
    self.triggerManager:InvokeTriggers(attackerArray, receiverArray, "Battle", args, nil, nil)
end
```

#### ë¯¸ë‹ˆì–¸ ì†Œí™˜ (Summon)
```lua
method void Summon(table blueprintTable, Minion pivot, boolean isPlaying)
    local minionTable = {}
    
    -- ê° í”Œë ˆì´ì–´ë³„ë¡œ ë¯¸ë‹ˆì–¸ ìƒì„±
    for player, blueprintArray in pairs(blueprintTable) do
        local availableSpace = player.field.capacity - #player.field.minionArray
        local minionArray = self.duel:ShareAcquiredMinions(
            math.min(#blueprintArray, availableSpace))
        
        -- ì„¤ê³„ë„ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë¯¸ë‹ˆì–¸ ì„¤ì •
        for i, minion in ipairs(minionArray) do
            local blueprint = blueprintArray[i]
            minion:SetPlayer(player)
            minion:SetBlueprint(blueprint)
        end
        
        -- í•„ë“œì— ë°°ì¹˜
        player.field:InsertMinions(minionArray, pivot)
    end
    
    -- ì†Œí™˜ íŠ¸ë¦¬ê±° ë°œë™
    self.triggerManager:InvokeTriggers(objectArray, receiverArray, "Summon", args, nil, nil)
end
```

## ğŸ¯ 3. ì…€ë ‰í„° ì‹œìŠ¤í…œ

### ì¡°ê±´ë¶€ ê°ì²´ ì„ íƒ

TaskManagerëŠ” ë‹¤ì–‘í•œ ìƒí™©ì—ì„œ íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ê°ì²´ë“¤ì„ ì„ íƒí•˜ê¸° ìœ„í•œ ì…€ë ‰í„° í•¨ìˆ˜ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤.

#### ê¸°ë³¸ ì…€ë ‰í„°ë“¤
```lua
-- ìƒì¡´ ìœ ë‹› ì„ íƒ
self.liveSelector = function(unit)
    return not unit.isDead
end

-- ê³µê°œëœ ì¹´ë“œ ì„ íƒ
self.openSelector = function(card)
    return not _Table:IsEmpty(card.info)
end

-- ì†ìƒëœ ë¯¸ë‹ˆì–¸ ì„ íƒ
self.damagedSelector = function(minion)
    return minion:IsDamaged()
end

-- ë™ê²°ëœ ë¯¸ë‹ˆì–¸ ì„ íƒ
self.freezeSelector = function(minion)
    return minion.isFreeze
end
```

#### íƒœê·¸ ê¸°ë°˜ ì…€ë ‰í„°ë“¤
```mermaid
graph TB
    A[íƒœê·¸ ê¸°ë°˜ ì…€ë ‰í„°] --> B[minionSelector<br/>ë¯¸ë‹ˆì–¸ íƒœê·¸]
    A --> C[skillSelector<br/>ìŠ¤í‚¬ íƒœê·¸]
    A --> D[alienSelector<br/>ì™¸ê³„ì¸ íƒœê·¸]
    A --> E[dragonSelector<br/>ë“œë˜ê³¤ íƒœê·¸]
    A --> F[bossSelector<br/>ë³´ìŠ¤ íƒœê·¸]
    
    B --> B1[ë¯¸ë‹ˆì–¸ ëŒ€ìƒ íš¨ê³¼]
    C --> C1[ìŠ¤í‚¬ ëŒ€ìƒ íš¨ê³¼]
    D --> D1[ì™¸ê³„ì¸ íŠ¹í™” íš¨ê³¼]
    E --> E1[ë“œë˜ê³¤ íŠ¹í™” íš¨ê³¼]
    F --> F1[ë³´ìŠ¤ íŠ¹í™” íš¨ê³¼]
```

### ì…€ë ‰í„° í™œìš© ì˜ˆì‹œ
```lua
-- ìƒëŒ€ë°© í•„ë“œì˜ ìƒì¡´ ë¯¸ë‹ˆì–¸ë“¤ì—ê²Œ ë°ë¯¸ì§€
local targets = _Table:Select(
    player.opponent.field:GetMinions(), 
    self.liveSelector
)

-- ìì‹ ì˜ ì†íŒ¨ì—ì„œ ë¯¸ë‹ˆì–¸ ì¹´ë“œë“¤ ì„ íƒ
local minionCards = _Table:Select(
    player.hand:GetCards(), 
    function(card) 
        return self.minionSelector(card) and self.openSelector(card) 
    end
)
```

## â° 4. ì§€ì—° ì‹œìŠ¤í…œê³¼ ë™ê¸°í™”

### ì§€ì—° ì‹œê°„ ê´€ë¦¬

#### AddDelay() ëˆ„ì  ì‹œìŠ¤í…œ
```lua
method void AddDelay(number delay)
    self.delay = self.delay + delay
    
    -- í•µì‹¬ ì§€ì—° ì‹œê°„ ê¸°ë¡
    table.insert(self.coreDelayTable, delay)
end
```

ê²Œì„ì˜ ëª¨ë“  ì‹œê°ì  íš¨ê³¼ì™€ ì• ë‹ˆë©”ì´ì…˜ì—ëŠ” ì ì ˆí•œ ì§€ì—° ì‹œê°„ì´ ì ìš©ë˜ì–´ ìì—°ìŠ¤ëŸ¬ìš´ ê²Œì„ ì§„í–‰ì„ ë³´ì¥í•©ë‹ˆë‹¤.

#### ë™ê¸°í™” ëŒ€ê¸° ì‹œìŠ¤í…œ
```mermaid
graph LR
    A[ì„œë²„ ì•¡ì…˜ ì‹¤í–‰] --> B[ì§€ì—° ì‹œê°„ ê³„ì‚°]
    B --> C[í´ë¼ì´ì–¸íŠ¸ ì• ë‹ˆë©”ì´ì…˜]
    C --> D[wait ëŒ€ê¸°]
    D --> E[ì„œë²„ ëŒ€ê¸° ì™„ë£Œ]
    E --> F[ë‹¤ìŒ ì•¡ì…˜ ì§„í–‰]
```

**ì„œë²„-í´ë¼ì´ì–¸íŠ¸ ë™ê¸°í™”**:
- ì„œë²„ëŠ” `AddDelay()`ë¡œ ì§€ì—° ì‹œê°„ ëˆ„ì 
- í´ë¼ì´ì–¸íŠ¸ëŠ” `wait()`ë¡œ ì‹¤ì œ ëŒ€ê¸°
- ëª¨ë“  ì•¡ì…˜ì´ ë™ì¼í•œ íƒ€ì´ë°ì— ì™„ë£Œë˜ë„ë¡ ë³´ì¥

## ğŸ”— 5. íŠ¸ë¦¬ê±° ì‹œìŠ¤í…œ ì—°ë™

### ì´ë²¤íŠ¸ ê¸°ë°˜ ê²Œì„ ì§„í–‰

#### íŠ¸ë¦¬ê±° ë°œë™ íŒ¨í„´
```lua
-- ëª¨ë“  ì£¼ìš” ì•¡ì…˜ì—ì„œ íŠ¸ë¦¬ê±° ë°œë™
self.triggerManager:InvokeTriggers(
    objectArray,        -- ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œí‚¨ ê°ì²´ë“¤
    receiverArray,      -- ì´ë²¤íŠ¸ë¥¼ ë°›ì„ ìˆ˜ ìˆëŠ” ëª¨ë“  ê°ì²´ë“¤
    "EventName",        -- ì´ë²¤íŠ¸ ì´ë¦„
    args,              -- ì´ë²¤íŠ¸ ì¸ìˆ˜ë“¤
    nil, nil           -- ì¶”ê°€ ë§¤ê°œë³€ìˆ˜ë“¤
)
```

#### ì£¼ìš” ê²Œì„ ì´ë²¤íŠ¸ë“¤
- **BeginRound** / **EndRound**: ë¼ìš´ë“œ ì‹œì‘/ì¢…ë£Œ
- **BeginTurn** / **EndTurn**: í„´ ì‹œì‘/ì¢…ë£Œ  
- **Play**: ì¹´ë“œ í”Œë ˆì´
- **Battle**: ì „íˆ¬ ë°œìƒ
- **Summon**: ë¯¸ë‹ˆì–¸ ì†Œí™˜
- **Damage**: ë°ë¯¸ì§€ ì…ìŒ
- **Death**: ìœ ë‹› ì‚¬ë§
- **Draw**: ì¹´ë“œ ë“œë¡œìš°
- **Discard**: ì¹´ë“œ ë²„ë¦¬ê¸°

### íŠ¸ë¦¬ê±° ì—°ì‡„ ì²˜ë¦¬

#### ë³µì¡í•œ ìƒí˜¸ì‘ìš© í•´ê²°
```mermaid
sequenceDiagram
    participant TM as TaskManager
    participant TR as TriggerManager
    participant C1 as Card1
    participant C2 as Card2
    
    TM->>TR: Play íŠ¸ë¦¬ê±° ë°œë™
    TR->>C1: "ì¹´ë“œ í”Œë ˆì´ ì‹œ" íš¨ê³¼ ì‹¤í–‰
    C1->>TM: Summon ì•¡ì…˜ ìš”ì²­
    TM->>TR: Summon íŠ¸ë¦¬ê±° ë°œë™
    TR->>C2: "ë¯¸ë‹ˆì–¸ ì†Œí™˜ ì‹œ" íš¨ê³¼ ì‹¤í–‰
    C2->>TM: Damage ì•¡ì…˜ ìš”ì²­
    TM->>TR: Damage íŠ¸ë¦¬ê±° ë°œë™
```

TaskManagerëŠ” ë³µì¡í•œ ì¹´ë“œ íš¨ê³¼ë“¤ì˜ ì—°ì‡„ ë°˜ì‘ì„ ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.

## ğŸ® 6. ê²Œì„ ìƒíƒœ í™•ì¸

### ê²Œì„ ì¢…ë£Œ ì¡°ê±´ ì²´í¬

#### ìŠ¹ë¶€ ê²°ì • ë¡œì§
TaskManagerëŠ” ê° ì•¡ì…˜ í›„ ê²Œì„ ì¢…ë£Œ ì¡°ê±´ì„ í™•ì¸í•©ë‹ˆë‹¤:
- í”Œë ˆì´ì–´ ì²´ë ¥ì´ 0 ì´í•˜ì¸ì§€
- ë±ì´ ë¹„ì–´ìˆëŠ”ì§€  
- íŠ¹ìˆ˜í•œ ìŠ¹ë¦¬ ì¡°ê±´ì´ ë‹¬ì„±ë˜ì—ˆëŠ”ì§€

```lua
-- ì•¡ì…˜ ì™„ë£Œ í›„ ê²Œì„ ìƒíƒœ í™•ì¸
if self:ShouldEndGame() then
    local winner = self:DetermineWinner()
    self.duel:EndMatch(winner)
end
```

## ğŸ’¡ ì½”ë“œ ì°¸ì¡°

í•µì‹¬ ê²Œì„ ì§„í–‰ ì œì–´ ë¡œì§:
- `TaskManager.mlua :: BeginRound()` â€” ë¼ìš´ë“œ ì‹œì‘ ì œì–´
- `TaskManager.mlua :: BeginTurn()` â€” í„´ ì‹œì‘ ì œì–´
- `TaskManager.mlua :: DeclareEndRound()` â€” ë¼ìš´ë“œ ì¢…ë£Œ ì„ ì–¸ ì²˜ë¦¬
- `TaskManager.mlua :: RunBatch()` â€” ë°°ì¹˜ ì²˜ë¦¬ ì‹œìŠ¤í…œ
- `TaskManager.mlua :: Play()` â€” ì¹´ë“œ í”Œë ˆì´ ì²˜ë¦¬
- `TaskManager.mlua :: Battle()` â€” ì „íˆ¬ ì²˜ë¦¬
- `TaskManager.mlua :: Summon()` â€” ë¯¸ë‹ˆì–¸ ì†Œí™˜ ì²˜ë¦¬

TaskManagerëŠ” ë©”ì´í”Œ ë“€ì–¼ì˜ ë³µì¡í•œ ê²Œì„ ì§„í–‰ì„ ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬í•˜ë©°, ëª¨ë“  ê²Œì„ ìš”ì†Œë“¤ì´ ì˜¬ë°”ë¥¸ ìˆœì„œì™€ íƒ€ì´ë°ìœ¼ë¡œ ì‹¤í–‰ë˜ë„ë¡ ë³´ì¥í•˜ëŠ” í•µì‹¬ ì‹œìŠ¤í…œì…ë‹ˆë‹¤.
